package com.csds393.yacht.calendar

import java.time.*

/**
 * Represents an event that re-occurs on a predictable schedule.
 * Concrete instances of CalendarEvent can be generated by providing a window of time
 * Currently only supports events separated by a whole number of days.
 * @property activeWindow  the window of time when this event re-occurs
 */
data class RecurringCalendarEvent(
    private val eventBase: CalendarEvent,
    private val activeWindow: ClosedRange<LocalDate>,
    private val datePattern: DatePattern,
) {

    private val duration: Period? = with(eventBase) { endDate?.until(startDate)?.negated() }

    val details: CalendarEvent.Details
        get() = eventBase.details


    /** Generates the list of occurrences of this recurring event that occur in [window] */
    fun generateEventsBetween(window: ClosedRange<LocalDate>): List<CalendarEvent> {
        // get first occurrence, while still in window, generate
        var nextOccurrence = earliestMutualFitWith(window.start)
        val endDate = minOf(window.endInclusive, activeWindow.endInclusive)
        val generatedEvents = mutableListOf<CalendarEvent>()
        while (! nextOccurrence.isAfter(endDate)) {
            generatedEvents.add(eventBase.copy(
                startDate = nextOccurrence,
                endDate = duration?.let { nextOccurrence.plus(duration) },
            ))
            nextOccurrence = datePattern.nextOccurrenceAfter(nextOccurrence)
        }
        return generatedEvents
    }

    /** Returns whether at least instance of this recurring event occurs in [window] */
    fun occursWithinWindow(window: ClosedRange<LocalDate>): Boolean {
        // Soonest occurrence after both window's start
        val soonestDate = earliestMutualFitWith(window.start)
        // is it <= both ends
        return !soonestDate.isAfter(minOf(window.endInclusive, activeWindow.endInclusive))
    }

    /** Returns the earliest Date fitting [datePattern] on or after both [activeWindow].start and [otherStart] */
    private fun earliestMutualFitWith(otherStart: LocalDate) =
        datePattern.nextOccurrenceFrom(maxOf(otherStart, activeWindow.start))
}
