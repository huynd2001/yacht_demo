package com.csds393.yacht.calendar

import androidx.room.*
import androidx.room.ForeignKey.CASCADE
import java.time.*

/**
 * Represents an event that re-occurs on a predictable schedule.
 * Concrete instances of CalendarEvent can be generated by providing a window of time
 * Currently only supports events separated by a whole number of days.
 * @property activeWindow  the window of time when this event re-occurs
 */
@Entity(tableName = "recurring_events")
data class RecurringCalendarEvent(
    @Embedded
    val eventBase: CalendarEvent,
    val activeWindow: ClosedRange<LocalDate>,
    val datePattern: DatePattern,
    @PrimaryKey(autoGenerate = true)
    val rec_id: Long? = null,
) {
    @delegate:Ignore
    private val duration: Period by lazy { with(eventBase) { startDate.until(endDate) } }

    fun details(): CalendarEvent.Details = eventBase.details

    /** Generates the list of occurrences of this recurring event that occur in [window] */
    fun generateEventsBetween(window: ClosedRange<LocalDate>, exceptions: Collection<LocalDate> = setOf()) =
        datePattern.getOccurrencesInWindows(window, activeWindow)
            .filterNot { it in exceptions }
                // negative id to distinguish from normal events' ids
            .map { eventBase.copy(startDate = it, endDate = it.plus(duration), id = -rec_id!!) }

    /** Returns whether at least one instance of this recurring event occurs in [window] */
    fun occursWithinWindow(window: ClosedRange<LocalDate>): Boolean {
        // Strict lower-bound of soonest occurrence
        val soonestDate = datePattern.nextOccurrenceFrom(maxOf(window.start, activeWindow.start))
        val latestDate = minOf(window.endInclusive, activeWindow.endInclusive)
        return !soonestDate.isAfter(latestDate)
    }

    fun toMap() = buildMap {
        putAll(eventBase.toMap())
        put("windowStart", activeWindow.start.toString())
        put("windowEnd", activeWindow.endInclusive.toString())
        put("datePatternSerialized", DatePattern.datePatternToInt(datePattern))
        rec_id?.let { put("rec_id", rec_id.toString()) }
    }

    companion object {
        fun fromMap(map: Map<String, String>) =
                RecurringCalendarEvent(
                        eventBase = CalendarEvent.fromMap(map),
                        activeWindow = LocalDate.parse(map.getValue("windowStart"))..LocalDate.parse(map.getValue("windowEnd")),
                        datePattern = DatePattern.intToDatePattern(java.lang.Long.parseLong(map.getValue("datePatternSerialized"))),
                        rec_id = map["rec_id"]?.let { java.lang.Long.parseLong(it) }
                )
    }


    @Entity(
       tableName = "recurrence_exceptions",
       primaryKeys = ["date", "event_id"],
       indices = [Index(value=["event_id"])],
       foreignKeys = [ForeignKey(
               entity = RecurringCalendarEvent::class,
               parentColumns = ["rec_id"],
               childColumns = ["event_id"],
               onUpdate = CASCADE,
               onDelete = CASCADE,
       )]
    )
    /** An excluded [date] for a recurring event */
    data class Exception(val date: LocalDate, val event_id: Long)

}
