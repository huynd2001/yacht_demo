package com.csds393.yacht.calendar

import java.time.*

/**
 * Represents an event that re-occurs on a predictable schedule.
 * Concrete instances of CalendarEvent can be generated by providing a window of time
 * Currently only supports events separated by a whole number of days.
 * @property activeWindow  the window of time when this event re-occurs
 */
//  could serialize datePattern to 64bit long. 4 bits for type, 8 bits for first second third fields
// or database side is normalized, wrapped into unified object when given to frontend
data class RecurringCalendarEvent(
    private val eventBase: CalendarEvent,
    private val activeWindow: ClosedRange<LocalDate>,
    private val datePattern: DatePattern,
) {

    private val duration: Period by lazy { with(eventBase) { startDate.until(endDate) } }

    val details: CalendarEvent.Details
        get() = eventBase.details


    /** Generates the list of occurrences of this recurring event that occur in [window] */
    fun generateEventsBetween(window: ClosedRange<LocalDate>) =
        datePattern.getOccurrencesInWindows(window, activeWindow)
            .map { eventBase.copy(startDate = it, endDate = it.plus(duration)) }

    /** Returns whether at least one instance of this recurring event occurs in [window] */
    fun occursWithinWindow(window: ClosedRange<LocalDate>): Boolean {
        // Strict lower-bound of soonest occurrence
        val soonestDate = datePattern.nextOccurrenceFrom(maxOf(window.start, activeWindow.start))
        val latestDate = minOf(window.endInclusive, activeWindow.endInclusive)
        return !soonestDate.isAfter(latestDate)
    }
}
